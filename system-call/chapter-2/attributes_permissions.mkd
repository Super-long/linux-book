前面我们介绍了文件的创建，打开，读写，关闭。这一小节主要跟大家介绍一下文件的属性和权限。如果大家读过鸟哥的话肯定对ls命令很熟悉了。我们在我们的终端（ctrl+alt+t）上键入ls -l之后，会产生什么效果？我们先介绍具体的系统调用，后面呢，我们会具体一个例子来体现这些系统调用的使用。

![](images/ls.png)

效果就像上图一样。我们可以看到的所有的数据，都是文件的属性的一部分。比如：前面看到文件的权限，所属用户，所属组等等。在这一小节都会跟大家做一个说明。OK,现在就进入文件属性和权限的学习吧。

我们可以使用stat/fstat/lstat函数来获取文件的属性。

##系统调用——stat/fstat/lstat

```
#include<sys/types.h>
#include<sys/stat.h>
#include<unistd.h>

int stat(const char *filename, struct stat *buf);
int fstat(int fd, struct stat *buf);
int lstat(const char *file_name, struct stat *buf);

这三个函数成功都返回0，失败返回-1;
```
这三个系统调用的第一个参数都是确定是哪个文件的，fstat是文件描述符（需要用open打开），其他两个是文件路径。那lstat和stat的区别是什么？答案很简单，如果文件是符号链接时，lstat返回的是符号链接本身的信息，而stat返回的是符号链接所指向的文件的信息。
第二个参数是将文件的信息保存在的结构体。当然，我们第二个参数需要好好聊聊。

我们可以在man手册上查看到stat结构体的结构：

```
struct stat {
    dev_t     st_dev;     /* 文件的设备编号 */
    ino_t     st_ino;     /* inode号 */
    mode_t    st_mode;    /* 文件的类型和存取的权限 */
    nlink_t   st_nlink;   /* 连到该文件的硬连接数目，初始为1 */
    uid_t     st_uid;     /* 用户ID */
    gid_t     st_gid;     /* 组ID */
    dev_t     st_rdev;    /* (设备类型)若此文件为设备文件，则为其设备编号 */
    off_t     st_size;    /* 文件大小（单位字节） */
    blksize_t st_blksize; /* 文件系统的块（I/O缓冲）大小*/
    blkcnt_t  st_blocks;  /* 块数 */
    time_t    st_atime;   /* 最后一次访问时间 */
    time_t    st_mtime;   /* 最后一次修改时间 */
    time_t    st_ctime;   /* 最后一次改变时间(指属性) */
};
```
从给出的解释已经不难看出它们的作用了。但下面我还要讲一下几个经常用到或者说是比较重要的字段。

###st_mode字段：下图是st_mode位掩码的布局。

![](images/st_mode.jpg)

图中User,Group,Other分别代表这三个不同身份的人对此文件使用权限。w（写），r（读），x（执行）。在代码中，我们可以将st_mode和S_IFMT相与（&），就可以从中获取文件类型。例如：

```
if((statbuf.st_mode & S_IFMT) == S_IFREG)
    printf("regular file\n");
```

现在我们还可以利用标准宏将其简化：

```
if(S_IDREG(statbuf_.st_mode))
    printf("regular file\n");
```
下图是常用来检查文件类型的宏：

![](images/testmacro.png)

ps：除去如图的"()"符号，就可以用第一种方式来判断文件属性了。


###各种time（文件时间戳）

关于时间的三个字段，是自Epoch以来的所有秒数。也就是说，要想显示我们清楚的时间格式我们必须要进行转换。例如：
```
asctime(gmtime(&Time))；

```

##系统调用——utime/utimes
前面我们看到，文件属性里面有事件戳这个信息，每次当我们修改该文件时候，就需要修改时间戳。
```
#include<utime.h>

int utime(const char *pathname, const struct utimbuf *times);

成功时返回0，失败返回-1并设置errno位。

#include<sys/time.h>

int utimes(const char *pathname, const struct timeval tv[2]);

成功时返回0，失败返回-1,并设置errno位。
```

两个函数第一个参数都表示文件，不同点在于第二个参数，utimes可设置的精度达到微秒级。我们首先看一下utimbuf的结构：

```
struct utimbuf {
               time_t actime;       /* 访问时间 */
               time_t modtime;      /* 修改时间 */
           };
```
接下来是timeval的结构：
```
  struct timeval {
               long tv_sec;        /* 秒 */
               long tv_usec;       /* 微秒 */
           };
```
utime的运作方式有两种：

1.  如果第二个参数为NULL，则将文件的访问时间设置为当前时间。当前进程要模具有特权级权限，要么其有效用户ID和文件的用户ID相匹配，并且对文件有写权限。
2.  若将第二个参数指向一个utimbuf的结构体，便会用指向的结构来更新文件的时间戳。此时的进程要么具有特权级权限，要么进程的有效用户ID必须匹配文件的用户ID。

utimes系统调用：

新的文件访问时间在tv[0]中指定，新的文件修改时间在tv[1]中指定。

