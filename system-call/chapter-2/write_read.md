我们前面介绍了文件的创建、打开和关闭。下面我们就要对文件的内容进行操作了。最基础的就是读写文件了。

##系统调用——read

read系统调用，是从指定的文件描述符中读取数据。
```
#include<unistd.h>

ssize_t read(int fd, void *buf, size_t count);

调用成功返回读到的字节数，读到文件尾则返回0。错误返回-1；
```

参数count代表最多能读取的字节数，buf是，指将文件中的内容读取到buf所指向的缓冲区中（buf是地址）。我们在上一小节的代码中可以看到这个代码：
        
    read(fd, &recvdata, 100）;
    这个代码就是从已经打开的文件描述符（fd），读取最多100个字节（可以小于100）到recvdata所指向的内存中。




##系统调用——write

write系统调用，是给指定的文件描述符中写入数据。

```
#include<unistd.h>

ssize_t write(int fd, void *buf, size_t count);

调用成功返回写入数据的字节数，错误返回-1。
```

参数count类似read系统调用，代表写入文件的字节数。buf是指，将buf所指向的存储区的数据写入文件。我们可能会遇到该系统调用返回值小于count。原因是磁盘已经满了或者进程资源对文件大小的限制。


当然，有很多童鞋就会想，这些系统调用跟我们刚接触的C语言中的文件读写有什么区别呢？

其实很简单，c语言的函数是在stdio库中，他们属于用户态的函数，这些函数在底层调用的还是现在所展示的这些系统调用。

![](images/two_kinds_of_io.png)


从这个图就能看出来它们之间的关系了吧？

OK，下面我们思考一个问题。我们能不能从文件中改或者读后一部分呢？答案是可以的。要实
现这个需求，我们必须要使用lseek这个系统调用。

在C语言中，我们使用指针，可以读取或者修改数组。在文件中，我们也有一个类似的概念，它叫“文件偏移量”。在我们读写文件，其实也是通过文件偏移量来实现的。每个打开的文件其实都有一个内核记录的偏移量。如果我们是从文件头来读写，那么文件偏移量就是0，完成读写后内核使其自增，直到到文件尾或者写完成.

我们可以使用lseek系统调用来改变文件偏移量。
```
#include<unistd.h>

off_t lseek(int fd, off_t offset, int whence);

调用成功返回文件新的偏移量，失败返回-1;
```

第一个参数是open系统调用后得到的文件描述符。offset指定了一个以字节为单位的数值。whence参数（简而言之就是设置起点）有如下几个：


SEEK_SET:

将文件偏移量设置为从文件起始点开始的offset个字节。

SEEK_CUR:

将文件偏移量设置为当前文件偏移量的offset个字节。绝对偏移量=当前文件偏移量+offset个字节。

SEEK_END:

将文件偏移量设置为起始于文件尾部（末尾字节的下一个算起）的offset个字节。

ps:offset可以是负值。例如：
```
lseek(fd, 0, SEEK_SET);
lseek(fd, 0, SEEK_END);
lseek(fd, -1, SEEK_END);
lseek(fd, -10, SEEK_CUR);
```
lseek通常能运用管道、FIFO、socket或者终端。调用失败将errno置为ESPIPE.感兴趣的童鞋可以查一下“文件空洞”。

##系统调用——